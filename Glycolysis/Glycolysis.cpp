/************************************************************************** 
 * SBML TO C Translator  : Model                                          * 
 * Date Modified   : 01 Sep 2005                                          * 
 * Current Version : 3.01                                                 * 
 *                                                                        * 
 * DESCRIPTION :                                                          * 
 * This file was generated by the SBML to C converter. The code contains  * 
 * the model represented by as set of ordinary differential equations. The* 
 * converter can also generate a hosting application which can be linked  * 
 * to this file to generate a complete simulation package.                * 
 *                                                                        * 
 * INSTRUCTIONS                                                           * 
 * Save this as a C header file with the name model.h. This file will be  * 
 * linked with with a hosting program to create a standalone simulator.   * 
 *                                                                        * 
 * To obtain the hosting application you can use the inspector tool that  * 
 * comes with the SBW installation. Select the translator and run the     * 
 * method, 'string getHostingApp()'. SBW is an open source application    * 
 * and can be obtained from www.sys-bio.org                               * 
 *                                                                        * 
 * AUTHORS                                                                * 
 * Ravishankar R. Vallabhajosyula (rrao@kgi.edu) and Herbert M. Sauro     * 
 * Keck Graduate Institute of Applied Life Sciences                       * 
 * 535 Watson Drive, Claremont, CA, 91711 USA                             * 
 *                                                                        * 
 **************************************************************************/

#include <iostream>
#include <fstream>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <ctime>
#include <gsl/gsl_odeiv2.h>
#include <gsl/gsl_errno.h>
#include <gsl/gsl_matrix.h>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_blas.h>

using namespace std;

#define ACCURACY_ABS 1e-8
#define ACCURACY_REL 0
#define STEP 1e-3
#define TIMESTEP 1
#define ODESOLVER gsl_odeiv2_step_msbdf
#define MAXINTTIME 10

#define MODULATE 1e-3
#define SMALL_NUMBER 1e-3

static double *p;      /*Vector containing the parameters in the System   */
static double *x;      /*Vector containing concentrations of ind species  */
static double *x0;     /*Vector containing initial species concentrations */
static double *xd;     /*Vector containing concentrations of dep species  */
static double *bc;     /*Vector containing all boundary species values    */
static double *dxdt;   /*Vector containing rates of changes of species    */
static double *rates;  /*Vector containing rate laws of all reactions     */
static double *T;      /*Vector containing values of the Conserved Sums   */

static double* f1 ;    /*Temporary vector used in evaluation of Jacobian  */ 
static double* f2;     /*Temporary vector used in evaluation of Jacobian  */ 

/* SETINITIALCONDITIONS
 * Sets the initial values of the all the floating species 
*/ 
const double coe=1;
void setInitialConditions ()
{
   x0[0] = 0.0182;                /* ADP */
   x0[1] = 3;                     /* ATP */
   x0[2] = 0.00116;               /* GAP */
   x0[3] = 0.42;                  /* PYR */
   x0[4] = 0.00373;               /* NADH */
   x0[5] = 0.0357;                /* _2PG */
   x0[6] = 0.0244;                /* DHAP */
   x0[7] = 0.2263;                /* G6P */
   x0[8] = 5.11;                  /* P */
   x0[9] = 0.0701;                /* F6P */
   x0[10] = 0.76;                 /* _3PG */
   x0[11] = 1.45;                 /* LAC */
   x0[12] = 2.5909;               /* GLU */
   x0[13] = 0.076;                /* O2 */
   x0[14] = 0.18;                 /* PEP */
   x0[15] = 0.0686;               /* BPG */
   x0[16] = 0.45;                 /* FBP */
   for(int i=0;i<17;i++)
	   x0[i]=x0[i]*coe;
}

/* SETCONSERVEDSUMVALUES
 * This method initializes the values of the conserved sum  
 * array.  
 */ 
void setConservedSumValues () 
{
   T[0] = -3.7133*coe;
   T[1] = 8.46*coe;
   T[2] = 6.54*coe;
   T[3] = 0.54973*coe;
}

/* UPDATEDEPSPECIESVALUES
 * Compute values of dependent species 
*/ 
void updateDepSpeciesValues (const double x[]) 
{
   xd[0] = T[0]  - 0.5*x[0] + 0.5*x[2] + 0.5*x[5] + 0.5*x[6] + 0.5*x[7] + 0.5*x[8] + 0.5*x[9] + 0.5*x[10] + 0.5*x[14] + x[15] + x[16];     /* AMP */
   xd[1] = T[1] ;     /* PCR */
   xd[2] = T[2] ;     /* CR */
   xd[3] = T[3]  - x[4];     /* NAD */
}

/* SETBOUNDARYCONDITIONS
 * Sets the values for all the boundary species 
 */ 
void setBoundaryConditions ()
{
   bc[0] = 5*coe;                     /* GLUe */   //Reduce input substrate concentration to reduce saturation
   bc[1] = 0.5*coe;                   /* LACe */
   bc[2] = 0.135*coe;                 /* O2e */
   bc[3] = 1e-7;                /* H */
}

/*
   J_OXYT = kf_OXYT * O2e - kf_OXYT / KE_OXYT * O2;

   J_AK = Vf_AK / KMf_AK * (ATP * AMP - ADP * ADP / KE_AK) / (1 + ATP * AMP / KMf_AK + ADP * ADP / KMb_AK);

   J_ATPase = Vf_ATPase / KMf_ATPase * (ATP - ADP * P * H / KE_ATPase) / (1 + ATP / KMf_ATPase + ADP * P * H / KMb_ATPase);

   J_MAS = V_OXPHOS * (PYR / (PYR + KM_OXPHOS_PYR)) * (O2 / (O2 + KM_OXPHOS_O2)) * (ADP / (ADP + KM_OXPHOS_ADP));

   J_OXPHOS = V_OXPHOS * (PYR / (PYR + KM_OXPHOS_PYR)) * (O2 / (O2 + KM_OXPHOS_O2)) * (ADP / (ADP + KM_OXPHOS_ADP));

   J_LACT = Vf_LACT / KM_LACT_LAC * (LAC - LACe / KE_LACT) / (1 + LAC / KM_LACT_LAC + LACe / KM_LACT_LACe);

   J_LDH = Vf_LDH / (KM_LDH_PYR * KM_LDH_NADH) * (PYR * NADH - LAC * NAD / KE_LDH) / (1 + PYR / KM_LDH_PYR + NADH / KM_LDH_NADH + PYR * NADH / (KM_LDH_PYR * KM_LDH_NADH) + LAC / KM_LDH_LAC + NAD / KM_LDH_NAD + LAC * NAD / (KM_LDH_LAC * KM_LDH_NAD));

   J_PK = Vf_PK / (KMf_PK * KA_PK_FBP) * (PEP * ADP * FBP - PYR * ATP * FBP / KE_PK) / (1 + PEP * ADP / KMf_PK + PYR * ATP / KMb_PK + PEP * ADP * FBP / (KMf_PK * KA_PK_FBP) + PYR * ATP * FBP / (KMb_PK * KA_PK_FBP) + FBP / KA_PK_FBP);

   J_ENO = Vf_ENO / KM_ENO__2PG * (_2PG - PEP / KE_ENO) / (1 + _2PG / KM_ENO__2PG + PEP / KM_ENO_PEP);

   J_PGM = Vf_PGM / KM_PGM__3PG * (_3PG - _2PG / KE_PGM) / (1 + _3PG / KM_PGM__3PG + _2PG / KM_PGM__2PG);

   J_PGK = Vf_PGK / KMf_PGK * (BPG * ADP - _3PG * ATP / KE_PGK) / (1 + BPG * ADP / KMf_PGK + _3PG * ATP / KMb_PGK);

   J_GAPDH = Vf_GAPDH / (KM_GAPDH_GAP * KM_GAPDH_NAD * KM_GAPDH_P) * (GAP * NAD * P - BPG * NADH * H / KE_GAPDH) / (1 + GAP / KM_GAPDH_GAP + NAD / KM_GAPDH_NAD + P / KM_GAPDH_P + BPG / KM_GAPDH_BPG + NADH / KM_GAPDH_NADH + GAP * NAD * P / (KM_GAPDH_GAP * KM_GAPDH_NAD * KM_GAPDH_P) + BPG * NADH * H / (KM_GAPDH_BPG * KM_GAPDH_NADH * KM_GAPDH_H));

   J_TPI = Vf_TPI / KM_TPI_DHAP * (DHAP - GAP / KE_TPI) / (1 + DHAP / KM_TPI_DHAP + GAP / KM_TPI_GAP);

   J_ALD = Vf_ALD / KMf_ALD * (FBP - DHAP * GAP / KE_ALD) / (1 + FBP / KMf_ALD + DHAP * GAP / KMb_ALD);

   J_PFK = Vf_PFK / (KMf_PFK * KA_PFK_AMP) * (F6P * ATP * AMP - FBP * ADP * H * AMP / KE_PFK) / (1 + F6P * ATP / KMf_PFK + FBP * ADP * H / KMb_PFK + F6P * ATP * AMP / (KMf_PFK * KA_PFK_AMP) + FBP * ADP * H * AMP / (KMb_PFK * KA_PFK_AMP) + AMP / KA_PFK_AMP);

   J_HPI = Vf_HPI / KM_HPI_G6P * (G6P - F6P / KE_HPI) / (1 + G6P / KM_HPI_G6P + F6P / KM_HPI_F6P);

   J_HK = Vf_HK / KMf_HK * (GLU * ATP - G6P * ADP * H / KE_HK) / (1 + GLU * ATP / KMf_HK + G6P * ADP * H / KMb_HK);

   J_GLUT = Vf_GLUT / KM_GLUT_GLUe * (GLUe - GLU / KE_GLUT) / (1 + GLUe / KM_GLUT_GLUe + GLU / KM_GLUT_GLU);

   g_OXYT = dG0_OXYT / RT + log(O2 / O2e);

   dG_OXYT = dG0_OXYT + RT * log(O2 / O2e);

   g_AK = dG0_AK / RT + log(ADP * ADP / (ATP * AMP));

   dG_AK = dG0_AK + RT * log(ADP * ADP / (ATP * AMP));

   g_ATPase = dG0_ATPase / RT + log(ADP * P * H / ATP);

   dG_ATPase = dG0_ATPase + RT * log(ADP * P * H / ATP);

   g_LACT = dG0_LACT / RT + log(LACe / LAC);

   dG_LACT = dG0_LACT + RT * log(LACe / LAC);

   g_LDH = dG0_LDH / RT + log(LAC * NAD / (PYR * NADH));

   dG_LDH = dG0_LDH + RT * log(LAC * NAD / (PYR * NADH));

   g_PK = dG0_PK / RT + log(PYR * ATP / (PEP * ADP));

   dG_PK = dG0_PK + RT * log(PYR * ATP / (PEP * ADP));

   g_ENO = dG0_ENO / RT + log(PEP / _2PG);

   dG_ENO = dG0_ENO + RT * log(PEP / _2PG);

   g_PGM = dG0_PGM / RT + log(_2PG / _3PG);

   dG_PGM = dG0_PGM + RT * log(_2PG / _3PG);

   g_PGK = dG0_PGK / RT + log(_3PG * ATP / (BPG * ADP));

   dG_PGK = dG0_PGK + RT * log(_3PG * ATP / (BPG * ADP));

   g_GAPDH = dG0_GAPDH / RT + log(BPG * NADH * H / (GAP * NAD * P));

   dG_GAPDH = dG0_GAPDH + RT * log(BPG * NADH * H / (GAP * NAD * P));

   g_TPI = dG0_TPI / RT + log(GAP / DHAP);

   dG_TPI = dG0_TPI + RT * log(GAP / DHAP);

   g_ALD = dG0_ALD / RT + log(DHAP * GAP / FBP);

   dG_ALD = dG0_ALD + RT * log(DHAP * GAP / FBP);

   g_PFK = dG0_PFK / RT + log(FBP * ADP * H / (F6P * ATP));

   dG_PFK = dG0_PFK + RT * log(FBP * ADP * H / (F6P * ATP));

   g_HPI = dG0_HPI / RT + log(F6P / G6P);

   dG_HPI = dG0_HPI + RT * log(F6P / G6P);

   g_HK = dG0_HK / RT + log(G6P * ADP * H / (GLU * ATP));

   dG_HK = dG0_HK + RT * log(G6P * ADP * H / (GLU * ATP));

   g_GLUT = dG0_GLUT / RT + log(GLU / GLUe);

   dG_GLUT = dG0_GLUT + RT * log(GLU / GLUe);
*/

/* INITPARAMETERS
 * Initializes all the parameters of the systems. These are  
 * stored as values in the parameter vector p[0]...p[np-1]  
 */ 
void initParameters () 
{
   p[0] = 1;                        /* J_AK*/
   p[1] = 1;                        /* J_ALD*/
   p[2] = 1;                        /* J_ATPase*/
   p[3] = 1;                        /* J_ENO*/
   p[4] = 1;                        /* J_GAPDH*/
   p[5] = 1;                        /* J_GLUT*/
   p[6] = 1;                        /* J_HK*/
   p[7] = 1;                        /* J_HPI*/
   p[8] = 1;                        /* J_LACT*/
   p[9] = 1;                        /* J_LDH*/
   p[10] = 1;                       /* J_MAS*/
   p[11] = 1;                       /* J_OXPHOS*/
   p[12] = 1;                       /* J_OXYT*/
   p[13] = 1;                       /* J_PFK*/
   p[14] = 1;                       /* J_PGK*/
   p[15] = 1;                       /* J_PGM*/
   p[16] = 1;                       /* J_PK*/
   p[17] = 1;                     /* J_TPI*/
   p[18] = 0.001;                   /* KA_PFK_AMP*/
   p[19] = 0.5;                     /* KA_PK_FBP*/
   p[20] = 1;                       /* KE_AK*/
   p[21] = 4.82234e-005;            /* KE_ALD*/
   p[22] = 478344;                  /* KE_ATPase*/
   p[23] = 6.06891;                 /* KE_ENO*/
   p[24] = 0.350348;                /* KE_GAPDH*/
   p[25] = 1;                       /* KE_GLUT*/
   p[26] = 2329.16;                 /* KE_HK*/
   p[27] = 0.32581;                 /* KE_HPI*/
   p[28] = 1;                       /* KE_LACT*/
   p[29] = 15385.1;                 /* KE_LDH*/
   p[30] = 1;                       /* KE_OXYT*/
   p[31] = 545.138;                 /* KE_PFK*/
   p[32] = 6083.56;                 /* KE_PGK*/
   p[33] = 0.0771841;               /* KE_PGM*/
   p[34] = 57773.9;                 /* KE_PK*/
   p[35] = 0.0471838;               /* KE_TPI*/
   p[36] = 0.15;                    /* KM_ENO_PEP*/
   p[37] = 0.03;                    /* KM_ENO__2PG*/
   p[38] = 0.1;                     /* KM_GAPDH_BPG*/
   p[39] = 0.002;                   /* KM_GAPDH_GAP*/
   p[40] = 1e-007;                  /* KM_GAPDH_H*/
   p[41] = 0.55;                    /* KM_GAPDH_NAD*/
   p[42] = 0.001;                   /* KM_GAPDH_NADH*/
   p[43] = 4;                       /* KM_GAPDH_P*/
   p[44] = 2.1;                     /* KM_GLUT_GLU*/
   p[45] = 2.1;                     /* KM_GLUT_GLUe*/
   p[46] = 0.0773;                  /* KM_HPI_F6P*/
   p[47] = 0.25;                    /* KM_HPI_G6P*/
   p[48] = 3;                       /* KM_LACT_LAC*/
   p[49] = 3;                       /* KM_LACT_LACe*/
   p[50] = 5;                       /* KM_LDH_LAC*/
   p[51] = 0.549;                   /* KM_LDH_NAD*/
   p[52] = 0.001;                   /* KM_LDH_NADH*/
   p[53] = 0.5;                     /* KM_LDH_PYR*/
   p[54] = 0.005;                   /* KM_OXPHOS_ADP*/
   p[55] = 0.005;                   /* KM_OXPHOS_O2*/
   p[56] = 0.001;                   /* KM_OXPHOS_PYR*/
   p[57] = 0.03;                    /* KM_PGM__2PG*/
   p[58] = 0.5;                     /* KM_PGM__3PG*/
   p[59] = 0.04;                    /* KM_TPI_DHAP*/
   p[60] = 0.002;                   /* KM_TPI_GAP*/
   p[61] = 2;                       /* KMb_AK*/
   p[62] = 8.29e-005;               /* KMb_ALD*/
   p[63] = 4.71e-009;               /* KMb_ATPase*/
   p[64] = 2.94e-010;               /* KMb_HK*/
   p[65] = 1.82e-010;               /* KMb_PFK*/
   p[66] = 1.5;                     /* KMb_PGK*/
   p[67] = 0.15;                    /* KMb_PK*/
   p[68] = 5;                       /* KMf_AK*/
   p[69] = 0.16;                    /* KMf_ALD*/
   p[70] = 3;                       /* KMf_ATPase*/
   p[71] = 7.5;                     /* KMf_HK*/
   p[72] = 0.23;                    /* KMf_PFK*/
   p[73] = 0.00118;                 /* KMf_PGK*/
   p[74] = 0.00177;                 /* KMf_PK*/
   p[75] = 2.47896;                 /* RT*/
   p[76] = 4.4;                     /* V_OXPHOS*/
   p[77] = 2000;                    /* Vf_AK*/
   p[78] = 321;                     /* Vf_ALD*/
   p[79] = 390;                     /* Vf_ATPase*/
   p[80] = 1340;                    /* Vf_ENO*/
   p[81] = 781;                     /* Vf_GAPDH*/
   p[82] = 100;                     /* Vf_GLUT*/
   p[83] = 176;                     /* Vf_HK*/
   p[84] = 858;                     /* Vf_HPI*/
   p[85] = 60;                      /* Vf_LACT*/
   p[86] = 434;                     /* Vf_LDH*/
   p[87] = 1769;                    /* Vf_PFK*/
   p[88] = 221;                     /* Vf_PGK*/
   p[89] = 528;                     /* Vf_PGM*/
   p[90] = 212;                     /* Vf_PK*/
   p[91] = 859;                     /* Vf_TPI*/

   
   p[92] = 0;                       /* dG0_AK*/
   p[93] = 24.64;                   /* dG0_ALD*/
   p[94] = -32.42;                  /* dG0_ATPase*/
   p[95] = -4.47;                   /* dG0_ENO*/
   p[96] = 2.6;                     /* dG0_GAPDH*/
   p[97] = 0;                       /* dG0_GLUT*/
   p[98] = -19.22;                  /* dG0_HK*/
   p[99] = 2.78;                    /* dG0_HPI*/
   p[100] = 0;                      /* dG0_LACT*/
   p[101] = -23.9;                  /* dG0_LDH*/
   p[102] = 0;                      /* dG0_OXYT*/
   p[103] = -15.62;                 /* dG0_PFK*/
   p[104] = -21.6;                  /* dG0_PGK*/
   p[105] = 6.35;                   /* dG0_PGM*/
   p[106] = -27.18;                 /* dG0_PK*/
   p[107] = 7.57;                   /* dG0_TPI*/
   p[108] = 1;                      /* dG_AK*/
   p[109] = 1;                      /* dG_ALD*/
   p[110] = 1;                      /* dG_ATPase*/
   p[111] = 1;                      /* dG_ENO*/
   p[112] = 1;                      /* dG_GAPDH*/
   p[113] = 1;                      /* dG_GLUT*/
   p[114] = 1;                      /* dG_HK*/
   p[115] = 1;                      /* dG_HPI*/
   p[116] = 1;                      /* dG_LACT*/
   p[117] = 1;                      /* dG_LDH*/
   p[118] = 0;                      /* dG_OXYT*/
   p[119] = 1;                      /* dG_PFK*/
   p[120] = 1;                      /* dG_PGK*/
   p[121] = 1;                      /* dG_PGM*/
   p[122] = 1;                      /* dG_PK*/
   p[123] = 1;                      /* dG_TPI*/
   p[124] = 1;                      /* g_AK*/
   p[125] = 1;                      /* g_ALD*/
   p[126] = 1;                      /* g_ATPase*/
   p[127] = 1;                      /* g_ENO*/
   p[128] = 1;                      /* g_GAPDH*/
   p[129] = 1;                      /* g_GLUT*/
   p[130] = 1;                      /* g_HK*/
   p[131] = 1;                      /* g_HPI*/
   p[132] = 1;                      /* g_LACT*/
   p[133] = 1;                      /* g_LDH*/
   p[134] = 0;                      /* g_OXYT*/
   p[135] = 1;                      /* g_PFK*/
   p[136] = 1;                      /* g_PGK*/
   p[137] = 1;                      /* g_PGM*/
   p[138] = 1;                      /* g_PK*/
   p[139] = 1;                      /* g_TPI*/
   p[140] = 164;                    /* kf_OXYT*/
   p[141] = 2.5;                    /* nnad*/
   p[142] = 12.5;                   /* nop*/
   p[143] = 3;                      /* nox*/
}

/* GETRATES
 * The getRates method returns all the rate laws evaluted based  
 * on species values at the timestep specified and parameters.   
 * 
 * PARAMETERS 
 *  time     current time of the simulation 
 *  x[]      vector containing values of all variables
 */ 
void getRates(double time, const double x[])
{
   updateDepSpeciesValues(x);
   rates[0] = p[82]/p[45]*(bc[0]-x[12]/p[25])/(1+bc[0]/p[45]+x[12]/p[44]);   //GLUT
   rates[1] = p[83]/p[71]*(x[12]*x[1]-x[7]*x[0]*bc[3]/p[26])/(1+x[12]*x[1]/p[71]+x[7]*x[0]*bc[3]/p[64])*(0.2/(0.2+x[7])); //HK
   rates[2] = p[84]/p[47]*(x[7]-x[9]/p[27])/(1+x[7]/p[47]+x[9]/p[46]);		//HGI
   rates[3] = p[87]/p[72]*(x[9]*x[1]-x[16]*x[0]*bc[3]/p[31])/(1+x[9]*x[1]/p[72]+x[16]*x[0]*bc[3]/p[65])*xd[0]/(xd[0]+p[18]); //PFK
   rates[4] = p[78]/p[69]*(x[16]-x[6]*x[2]/p[21])/(1+x[16]/p[69]+x[6]*x[2]/p[62]); //ALD
   rates[5] = p[91]/p[59]*(x[6]-x[2]/p[35])/(1+x[6]/p[59]+x[2]/p[60]); //TPI
   rates[6] = p[81]/(p[39]*p[41]*p[43])*(x[2]*xd[3]*x[8]-x[15]*x[4]*bc[3]/p[24])/(1+x[2]/p[39]+xd[3]/p[41]+x[8]/p[43]+x[15]/p[38]+x[4]/p[42]+x[2]*xd[3]*x[8]/(p[39]*p[41]*p[43])+x[15]*x[4]*bc[3]/(p[38]*p[42]*p[40]));  //GAPDH
   rates[7] = p[88]/p[73]*(x[15]*x[0]-x[10]*x[1]/p[32])/(1+x[15]*x[0]/p[73]+x[10]*x[1]/p[66]); //PGK
   rates[8] = p[89]/p[58]*(x[10]-x[5]/p[33])/(1+x[10]/p[58]+x[5]/p[57]); //PGM
   rates[9] = p[80]/p[37]*(x[5]-x[14]/p[23])/(1+x[5]/p[37]+x[14]/p[36]); //ENO
   rates[10] = p[90]/p[74]*(x[14]*x[0]-x[3]*x[1]/p[34])/(1+x[14]*x[0]/p[74]+x[3]*x[1]/p[67])*x[16]/(x[16]+p[19]); //PK
   rates[11] = p[86]/(p[53]*p[52])*(x[3]*x[4]-x[11]*xd[3]/p[29])/(1+x[3]/p[53]+x[4]/p[52]+x[3]*x[4]/(p[53]*p[52])+x[11]/p[50]+xd[3]/p[51]+x[11]*xd[3]/(p[50]*p[51])); //LDH
   rates[12] = p[85]/p[48]*(x[11]-bc[1]/p[28])/(1+x[11]/p[48]+bc[1]/p[49]);  //LACT
   rates[13] = p[76]*(x[3]/(x[3]+p[56]))*(x[13]/(x[13]+p[55]))*(x[0]/(x[0]+p[54])); //OxPhos
   rates[14] = p[76]*(x[3]/(x[3]+p[56]))*(x[13]/(x[13]+p[55]))*(x[0]/(x[0]+p[54])); //MAS
   rates[15] = p[79]/p[70]*(x[1]-x[0]*x[8]*bc[3]/p[22])/(1+x[1]/p[70]+x[0]*x[8]*bc[3]/p[63]); //ATPase
   rates[16] = p[77]/p[68]*(x[1]*xd[0]-x[0]*x[0]/p[20])/(1+x[1]*xd[0]/p[68]+x[0]*x[0]/p[61]); //AK
   rates[17] = p[140]*bc[2]-p[140]/p[30]*x[13]; //O2T
}



/* MODELFCN
 * This is the method that evaluates the right hand side of the     
 * system of equations governing the reaction network. It is called 
 * from the solver routine. It conforms to the same standard list   
 * of arguments allowing users to easily use other solver routines. 
 * 
 * PARAMETERS 
 *  neq      Number of equations comprising the system 
 *  time     current time of the simulation 
 *  x[]      vector containing values of all input variables 
 *  dxdt[]   vector containing values of right hand side evaluations 
 */ 
void modelfcn (int neq, double time, const double x[], double dxdt[]) 
{
   getRates (time, x);
   const double nop=12.5;
   const double nnad=2.5;
   const double nox=3;
   dxdt[0] =   + rates[1] + rates[3] - rates[7] - rates[10] - nop*rates[13] - nnad*rates[14] + rates[15] + 2*rates[16];  //ADP
   dxdt[1] =   - rates[1] - rates[3] + rates[7] + rates[10] + nop*rates[13] + nnad*rates[14] - rates[15] - rates[16];    //ATP
   dxdt[2] =   + rates[4] + rates[5] - rates[6];								//GAP
   dxdt[3] =   + rates[10] - rates[11] - rates[13];								//PYR
   dxdt[4] =   + rates[6] - rates[11] - rates[14];								//NADH
   dxdt[5] =   + rates[8] - rates[9];										//2PG
   dxdt[6] =   + rates[4] - rates[5];										//DHAP
   dxdt[7] =   + rates[1] - rates[2];										//G6P
   dxdt[8] =   - rates[6] - nop*rates[13] - nnad*rates[14] + rates[15];							//Pi
   dxdt[9] =   + rates[2] - rates[3];										//F6P
   dxdt[10] =   + rates[7] - rates[8];										//3PG
   dxdt[11] =   + rates[11] - rates[12];									//Lac
   dxdt[12] =   + rates[0] - rates[1];										//Glc
   dxdt[13] =   - nox*rates[13] + rates[17];									//O2
   dxdt[14] =   + rates[9] - rates[10];										//PEP
   dxdt[15] =   + rates[6] - rates[7];										//BPG
   dxdt[16] =   + rates[3] - rates[4];										//FBP
}

/* MALLOC_AND_VERIFY
 * This method returns a pointer to the desired vector after verifying that 
 * it has actually been created, and initialized to zero.  
 * 
 * PARAMETERS 
 *  n        Number of double values to allocate to the vector 
 *  err_str  Prints out this error string if memory cannot be allocated  
 */ 

/* JACOBIANORDER2
 * This method implements the 2nd order given by the following   
 * central difference using numerical approximation 
 *              df(x)/dx = (f(x+h) - f(x-h))/(2*h)                  
 * 
 * PARAMETERS 
 *  n        Number of species in the reaction system 
 *  neq      Number of equations of the system, here neq=nx 
 *  time     current time of the simulation 
 *  x[]      vector containing values of all variables  
 *  Jac      Pointer to an array of pointers storing Jacobian 
 */ 
void JacobianOrder2 (int n, int neq, double time, double x[], double **Jac)
{
   int i, j;
   double h_jac, h2_jac;

   for (j=0; j<n; j++) {
      if ((fabs(x[j])) < SMALL_NUMBER)
         h_jac = MODULATE;
      else {
         h_jac = MODULATE*x[j];
         h2_jac = 0.5/h_jac;
      }

      /* Increment x[j] by h to get function values at x+h */
      x[j] = x[j] + h_jac;
      modelfcn(n, time, x, f1);

      /* Decrement x[j] by 2h to get function values at x-h */
      x[j] = x[j] -2.0* h_jac;

      modelfcn(n, time, x, f2);
      for (i=0; i<neq; i++) { 
         Jac[i][j] = (f1[i] - f2[i])*h2_jac;
         if (fabs(Jac[i][j]) < SMALL_NUMBER) Jac[i][j] = 0.0;
      }

      /* Increment x[j] by h to revert back to original vals */
      x[j] = x[j] + h_jac;
   }
}

/* JACOBIANORDER4
 * This method implements the 4th order numerical approximation  
 * given by the following central difference relation               
 *       df(x)/dx = (f(x-2h) -8f(x-h) +8f(x+h) +f(x+2h))/(12*h)     
 * 
 * PARAMETERS 
 *  n        Number of species in the reaction system 
 *  neq      Number of equations of the system, here neq=nx 
 *  time     current time of the simulation 
 *  x[]      vector containing values of all variables  
 *  Jac      Pointer to an array of pointers storing Jacobian 
 */ 
void JacobianOrder4 (int n, int neq, double time, double x[], double **Jac) 
{
   int i, j;
   double h_jac, h12_jac; 

   for (j=0; j<n; j++) {
      if ((fabs(x[j])) < SMALL_NUMBER)
         h_jac = MODULATE;
      else {
         h_jac = MODULATE*x[j];
         h12_jac = 1.0/(12.0*h_jac);
      }

      /* Decrement x[j] by 2h to get function values at x-2h */
      x[j] = x[j] - 2.0*h_jac;
      modelfcn(n, time, x, f1);

      /* Increment x[j] by h to get function vals at x-h */
      x[j] = x[j] + h_jac;
      modelfcn(n, time, x, f2);

      /* sum f1 and f2 based on formula and store in f1 */
      for (i=0; i<neq; i++) f1[i] = f1[i] - 8.0*f2[i];

      /* Increment x[j] by 2h to get function vals at x+h */
      x[j] = x[j] + 2.0*h_jac;
      modelfcn(n, time, x, f2);

      /* sum f1 and f2 based on formula and store in f1 */
      for (i=0; i<neq; i++) f1[i] = f1[i] + 8.0*f2[i];

      /* Increment x[j] by h to get function vals at x+2h */
      x[j] = x[j] + h_jac;
      modelfcn(n, time, x, f2);

      /* sum f1 and f2 based on formula and store in f1 */
      for (i=0; i<neq; i++) f1[i] = f1[i] - f2[i];

      for (i=0; i<neq; i++) { 
         Jac[i][j] = (f1[i])/(12.0*h_jac);
         if (fabs(Jac[i][j]) < SMALL_NUMBER) Jac[i][j] = 0.0;
      }

      /* Decrement x[j] by 2h to get original function vals at x */
      x[j] = x[j] - 2.0*h_jac;
   }
}

/* CONSTRUCTOR
 * The main constructor for the model. Memory allocation for all the arrays 
 * is performed in this method. This method should be called to initialize  
 * the model before the simulation routine can be called.                   
 * 
 * PARAMETERS 
 *   nx   number of species              
 *   np   number of parameters           
 *   nr   number of reactions            
 *   nb  number of boundary conditions   
 */ 

/* DESTRUCTOR
 * The destructor method must be called to free memory allocated by the model 
 *    
 */ 
void destructor () 
{
   free(p);
   free(x);
   free(xd);
   free(x0);
   free(bc);
   free(dxdt);
   free(rates);
   free(T);

   /* free any memory that has been allocated for Jacobian evaluation */
   free(f1);
   free(f2);
}

/* GETNUMREACTIONS
 * Returns the number of Reactions 
 */ 
int getNumReactions () 
{
   return 18;
}

/* GETNUMPARAMETERS
 * Returns the number of Parameters 
 */ 
int getNumParameters () 
{
   return 144;
}

/* GETNUMSPECIES
 * Returns the number of Floating Species 
 */ 
int getNumSpecies () {
   return 21;
}

/* GETNUMINDSPECIES
 * Returns the number of Independent Species 
 */ 
int getNumIndSpecies ()
{
   return 17;
}

/* GETNUMDEPSPECIES
 * Returns the number of Dependent Species 
 */ 

int getNumDepSpecies ()
{
   return 4;
}

/* GETNUMEQUATIONS
 * Returns the number of Equations 
 */ 
int getNumEquations () 
{
   return 21;
}

/* GETNUMBOUNDARYCONDITIONS
 * Returns the number of Boundary Conditions 
 */ 
int getNumBoundaryConditions () 
{
   return 4;
}

/* SETPARAMETER
 * Allows users to set parameters in the model 
 * 
 * PARAMETERS 
 *   index   index of the parameter array to be set   
 *   value   the value that is being set   
 */ 
void setParameter (int index, double value) 
{
   if (( 0 <= index) && (index < getNumParameters())) 
      p[index] = value;
   else 
      fprintf(stderr, "Error in setParameter() : Index out of range");
}

/* GETPARAMETER
 * Returns the value of the parameters for a given index 
 * 
 * PARAMETERS 
 *   index   index of the parameter array to return   
 */ 
double getParameter (int index) 
{
   if (( 0 <= index) && (index < getNumParameters())) 
      return p[index];
   else { 
      fprintf(stderr, "Error in getParameter() : Index out of range");
      return EXIT_FAILURE; 
   }
}

static int NParams; //Number of parameters
static int NMets; //Number of metabolites
static int NRxns; //Number of reactions
static int NDep;  //Number of dependent species
static int NInd;  //Number of independent species
static int NBnd;  //Number of boundary conditions
static double **JMat;

void init(void)   //Initialize values for the parameters necessary for solving ODEs
{
	NParams=getNumParameters();
	NMets=getNumSpecies();
	NRxns=getNumReactions();
	NInd = getNumIndSpecies(); 
	NDep = getNumDepSpecies();
	NBnd = getNumBoundaryConditions();
	p     = new double[NParams];
	xd    = new double[NDep];
	x0    = new double[NInd];
	bc    = new double[NBnd];
	rates = new double[NRxns];
	T     = new double[NDep];
	JMat = new double*[NInd];
	f1 = new double[NInd];
	f2 = new double[NInd];  //Temporary vector in calculating the Jacobian
	setConservedSumValues(); 
	setBoundaryConditions();
	for(int i=0;i<NInd;i++)
		JMat[i]=new double[NInd];
	return;
}

int func (double t, const double x[], double f[],void *params)  //Calculate dxdt from x
{
	double *p0=(double *)params;
	for(int i=0;i<NParams;i++)
		p[i]=p0[i];
	modelfcn(NInd,t,x,f); 
	return GSL_SUCCESS;
}

int Jac(double t, const double y[],double *dfdy,double dfdt[],void *params) //Calculate dfdy and dfdt from x	
{
	const double nop=12.5;
	const double nnad=2.5;
	const double nox=3;
	double *p0=(double *)params;
	for(int i=0;i<NParams;i++)
		p[i]=p0[i];
	static double *y_nonconst=new double[NInd];
	for(int i=0;i<NInd;i++)
	{
		y_nonconst[i]=y[i];
		dfdt[i]=0;
	}

	static gsl_matrix *DfDr=gsl_matrix_alloc(NInd,NRxns);
	static gsl_matrix *DrDx=gsl_matrix_alloc(NRxns,NInd);
	static gsl_matrix *DrDxd=gsl_matrix_alloc(NRxns,NDep);
	static gsl_matrix *DxdDx=gsl_matrix_alloc(NDep,NInd);
	static double *x=new double[NInd];
	for(int i=0;i<NInd;i++)
		x[i]=y[i];
   	updateDepSpeciesValues(x);
	

#include"dfdr.cpp"
#include"dxddx.cpp"
#include"drdx.cpp"
#include"drdxd.cpp"

	gsl_matrix_view dfdy_mat=gsl_matrix_view_array(dfdy,NInd,NInd);
	gsl_matrix *mm=&dfdy_mat.matrix;
	gsl_blas_dgemm(CblasNoTrans,CblasNoTrans,1,DrDxd,DxdDx,1,DrDx);
	for(int i=0;i<NInd;i++)
		for(int j=0;j<NInd;j++)
			gsl_matrix_set(mm,i,j,0);
	gsl_blas_dgemm(CblasNoTrans,CblasNoTrans,1,DfDr,DrDx,1,mm);
	static int nrun=0;
	nrun++;
	if(nrun==1)
	{
		for(int i=0;i<NInd;i++)
		{
			for(int j=0;j<NInd;j++)
				cout<<dfdy[i*NInd+j]<<" ";
				//cout<<gsl_matrix_get(mm,i,j)<<" ";
			cout<<endl;
		}
	}
	return GSL_SUCCESS;
}

int isSteadyState(double x[],double *params)  
//Determine if the system is in steady state
{
	for(int i=0;i<NParams;i++)
		p[i]=params[i];
	static double *dxdt=new double[NInd];
	modelfcn(NInd,0,x,dxdt);
	const double small=1e-4;
	for(int i=0;i<NInd;i++)
	{
		if(fabs(dxdt[i]/x[i])>small)
		{
			return false;
		}
	}
	return true;
}

bool isPositiveSol(double x[])
//Check if every metabolite has nonnegative concentration
{
	for(int i=0;i<NInd;i++)
	{
		if(x[i]<0)
			return false;
	}
	return true;
}

double *Simulation(double *params)   
//Solve the ODEs until the system reaches steady state
{
	gsl_odeiv2_system sys = {func, Jac, NInd, params};
	gsl_odeiv2_driver * d = gsl_odeiv2_driver_alloc_y_new (&sys, ODESOLVER,STEP, ACCURACY_ABS, ACCURACY_REL);
	double time=0;
	double *y=new double[NInd];
	setInitialConditions();
	//ofstream fout("Curves.txt");
	for(int i=0;i<NInd;i++)
		y[i]=x0[i];
	double clock0=clock();
	const double tlimit=5;
	int i=0;
	const double step=1;//0.01;
	while(1)
	{	
		i++;
		double tend=step*(double)i;
		while(time<tend)
		{
			int status=gsl_odeiv2_driver_apply(d,&time,tend,y);
			double tcost=(clock()-clock0)/CLOCKS_PER_SEC;
			if(status!=GSL_SUCCESS || tcost>tlimit || isPositiveSol(y)==false)
			{
				cout<<"Error in solving ODEs: status="<<status<<endl;
				if(tcost>tlimit)
					cout<<"ODE solver too slow. Current time:"<<time<<endl;
				for(int k=0;k<NInd;k++)
					y[k]=-1;
				return y;
			}
			if(isSteadyState(y,params))
				return y;
		}
	}
	return y;
}


gsl_matrix *calFCC(double *params)
//Calculate flux control coefficients based on a parameter vector
{
	const int VmaxPos[]={76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91};
	const int NVmax=16;
	double *y0=Simulation(params);
	double *rate_left=new double[NRxns];
	double *rate_right=new double[NRxns];
	gsl_matrix *m=gsl_matrix_alloc(NRxns,NVmax);
	const double fc=1.001;
	for(int i=0;i<NVmax;i++)
	{
		int pos=VmaxPos[i];
		params[pos]=params[pos]*fc;
		double *y_right=Simulation(params);
		if(y_right[0]<-0.5)
		{
			for(int j=0;j<NVmax;j++)
				for(int k=0;k<NRxns;k++)
					gsl_matrix_set(m,k,j,-1);
			return m;
		}

		getRates(0,y_right);
		for(int j=0;j<NRxns;j++)
			rate_right[j]=rates[j];
		params[pos]=params[pos]/(fc*fc);
		double *y_left=Simulation(params);
		if(y_left[0]<-0.5)
		{
			for(int j=0;j<NVmax;j++)
				for(int k=0;k<NRxns;k++)
					gsl_matrix_set(m,k,j,-1);
			return m;
		}
		getRates(0,y_left);
		for(int j=0;j<NRxns;j++)
			rate_left[j]=rates[j];
		params[pos]=params[pos]*fc;
		for(int j=0;j<NRxns;j++)
			gsl_matrix_set(m,j,i,log(rate_right[j]/rate_left[j])/log(fc*fc));
	}
	return m;
}

double *calStatus(double *params,double *ss)
//Return [WE,JLac,NAD/NADH,ATP/ADP]
//Store steady state concentrations in ss
{
	double *y=Simulation(params);
	for(int i=0;i<NInd;i++)
		ss[i]=y[i];
	double *ps=new double[4];
	if(y[0]<-0.5)
	{
		for(int i=0;i<4;i++)
			ps[i]=-1;
		return ps;
	}
	getRates(0,y);
	ps[0]=rates[11]/rates[13];
	ps[1]=rates[11];
	ps[2]=xd[3]/y[4];
	ps[3]=y[1]/y[0];
	return ps;
}

double ran01(void)
//Generate a random number from uniform distribution in (0,1)
{
	const gsl_rng_type * T;
	T = gsl_rng_default;
	gsl_rng_env_setup();
	static gsl_rng *r = gsl_rng_alloc (T);
	double u= gsl_rng_uniform (r);
	return u;
}

double **init_matrix(int nsamples,int dim)
//Generate a nsamples*dim random matrix with each element ranging from 0 to 1
{
	double inf=-1;
	double sup=1;
	double **mat=new double*[nsamples];
	for(int i=0;i<nsamples;i++)
	{
		mat[i]=new double[dim];
		for(int j=0;j<dim;j++)
			mat[i][j]=inf+(sup-inf)*ran01();
	}
	return mat;
}

void random_permute(double **mat,int nsamples,int dim)
//Randomly permute the columns of the random matrix
{
	int tar;
	double bridge;
	for(int i=0;i<nsamples;i++)
	{
		for(int j=0;j<dim;j++)
		{
			tar=rand();
			tar=tar%nsamples;
			bridge=mat[i][j];
			mat[i][j]=mat[tar][j];
			mat[tar][j]=bridge;
		}
	}
	return;
}

double **LHS_sample(int nsamples,int dim)
//Generate a random matrix using Latin hypercube sampling
{
	double **mat=init_matrix(nsamples,dim);
	random_permute(mat,nsamples,dim);
	return mat;
}

double **Samp_ParamsChange(int nsamples)
//Generate random coefficients to perturb the Vmax's
{
	const int NVar=16;
	double **PC=LHS_sample(nsamples,NVar);
	return PC;
}

double *ChangeParams(double *VecPC,double *p0)
//Randomly perturb the Vmax's to generate new parameter sets
{
	const int VmaxStart=76;
	const int VmaxEnd=91;
	const int KmStart=36;
	const int KmEnd=60;
	double *p1=new double[NParams];
	int count=0;
	for(int i=0;i<NParams;i++)
	{
		p1[i]=p0[i];
		if((i-VmaxStart)*(i-VmaxEnd)<=0)
		{
			double r=1;//0.2;
			/*
			if(count==6 || count==9)
				r=1;
			else if(count==7 || count==11 || count==12)
				r=0.5;
			*/
			p1[i]=p1[i]*pow(10.0,r*VecPC[count]);
			count++;
		}
	}
	return p1;
}

double dgv(double f,double r)
//Calculate deltaG of a reaction from the forward and backward fluxes
{
	const double RT=2.47896;
	return -RT*log(f/r);
}

void saturation(double x[],double *kappa_f,double *kappa_r)
//Calculate the saturation term for each reaction
{
	updateDepSpeciesValues(x);
	kappa_f[0]=bc[0]/p[45]/(1+bc[0]/p[45]+x[12]/p[44]); 
	kappa_r[0]=x[12]/p[44]/(1+bc[0]/p[45]+x[12]/p[44]);
	kappa_f[1]=x[12]*x[1]/p[71]/(1+x[12]*x[1]/p[71]+x[7]*x[0]*bc[3]/p[64]);
	kappa_r[1]=x[7]*x[0]*bc[3]/p[64]/(1+x[12]*x[1]/p[71]+x[7]*x[0]*bc[3]/p[64]);
	kappa_f[2]=x[7]/p[47]/(1+x[7]/p[47]+x[9]/p[46]); 
	kappa_r[2]=x[9]/p[46]/(1+x[7]/p[47]+x[9]/p[46]);
	kappa_f[3]=x[9]*x[1]/p[72]/(1+x[9]*x[1]/p[72]+x[16]*x[0]*bc[3]/p[65]);
	kappa_r[3]=x[16]*x[0]*bc[3]/p[65]/(1+x[9]*x[1]/p[72]+x[16]*x[0]*bc[3]/p[65]);
	kappa_f[4]=x[16]/p[69]/(1+x[16]/p[69]+x[6]*x[2]/p[62]);
	kappa_r[4]=x[6]*x[2]/p[62]/(1+x[16]/p[69]+x[6]*x[2]/p[62]);
	kappa_f[5]=x[6]/p[59]/(1+x[6]/p[59]+x[2]/p[60]);
	kappa_r[5]=x[2]/p[60]/(1+x[6]/p[59]+x[2]/p[60]);
	kappa_f[6]=(x[2]/p[39]+xd[3]/p[41]+x[8]/p[43]+x[2]*xd[3]*x[8]/(p[39]*p[41]*p[43]))/(1+x[2]/p[39]+xd[3]/p[41]+x[8]/p[43]+x[15]/p[38]+x[4]/p[42]+x[2]*xd[3]*x[8]/(p[39]*p[41]*p[43])+x[15]*x[4]*bc[3]/(p[38]*p[42]*p[40]));
	kappa_r[6]=(x[15]/p[38]+x[4]/p[42]+x[15]*x[4]*bc[3]/(p[38]*p[42]*p[40]))/(1+x[2]/p[39]+xd[3]/p[41]+x[8]/p[43]+x[15]/p[38]+x[4]/p[42]+x[2]*xd[3]*x     [8]/(p[39]*p[41]*p[43])+x[15]*x[4]*bc[3]/(p[38]*p[42]*p[40]));
	kappa_f[7]=x[15]*x[0]/p[73]/(1+x[15]*x[0]/p[73]+x[10]*x[1]/p[66]);
	kappa_r[7]=x[10]*x[1]/p[66]/(1+x[15]*x[0]/p[73]+x[10]*x[1]/p[66]);
	kappa_f[8]=x[10]/p[58]/(1+x[10]/p[58]+x[5]/p[57]);
	kappa_r[8]=x[5]/p[57]/(1+x[10]/p[58]+x[5]/p[57]);
	kappa_f[9]=x[5]/p[37]/(1+x[5]/p[37]+x[14]/p[36]);
	kappa_r[9]=x[14]/p[36]/(1+x[5]/p[37]+x[14]/p[36]);
	kappa_f[10]=x[14]*x[0]/p[74]/(1+x[14]*x[0]/p[74]+x[3]*x[1]/p[67]);
	kappa_r[10]=x[3]*x[1]/p[67]/(1+x[14]*x[0]/p[74]+x[3]*x[1]/p[67]);
	kappa_f[11]=(x[3]/p[53]+x[4]/p[52]+x[3]*x[4]/(p[53]*p[52]))/(1+x[3]/p[53]+x[4]/p[52]+x[3]*x[4]/(p[53]*p[52])+x[11]/p[50]+xd[3]/p[51]+x[11]*xd[3]/(p[50]*p[51]));
	kappa_r[11]=(x[11]/p[50]+xd[3]/p[51]+x[11]*xd[3]/(p[50]*p[51]))/(1+x[3]/p[53]+x[4]/p[52]+x[3]*x[4]/(p[53]*p[52])+x[11]/p[50]+xd[3]/p[51]+x[11]*xd[3]/(p[50]*p[51]));
	kappa_f[12]=x[11]/p[48]/(1+x[11]/p[48]+bc[1]/p[49]);
	kappa_r[12]=bc[1]/p[49]/(1+x[11]/p[48]+bc[1]/p[49]);
	kappa_f[13]=(x[3]/(x[3]+p[56]))*(x[13]/(x[13]+p[55]))*(x[0]/(x[0]+p[54]));
	kappa_r[13]=0;
	kappa_f[14]=(x[3]/(x[3]+p[56]))*(x[13]/(x[13]+p[55]))*(x[0]/(x[0]+p[54]));
	kappa_r[14]=0;	
	kappa_f[15]=x[1]/p[70]/(1+x[1]/p[70]+x[0]*x[8]*bc[3]/p[63]);
	kappa_r[15]=x[0]*x[8]*bc[3]/p[63]/(1+x[1]/p[70]+x[0]*x[8]*bc[3]/p[63]);
	kappa_f[16]=x[1]*xd[0]/p[68]/(1+x[1]*xd[0]/p[68]+x[0]*x[0]/p[61]);
	kappa_r[16]=x[0]*x[0]/p[61]/(1+x[1]*xd[0]/p[68]+x[0]*x[0]/p[61]);
	kappa_f[17]=0;
	kappa_r[17]=0;

	return;
}

void Conc2Sat(void)
//Calculate saturation terms based on concentrations of metabolites
{
	ifstream fin("MetConc_Sample.txt");
	ofstream fo_kf("Kf_Sample.txt");
	ofstream fo_kr("Kr_Sample.txt");
	double *ss=new double[NInd];
	double *kf=new double[NRxns];
	double *kr=new double[NRxns];
	int count=0;
	double c=0;
	while(1)
	{
		fin>>c;
		ss[(count++)%NInd]=c;
		if(count%NInd==0)
		{
			saturation(ss,kf,kr);
			for(int i=0;i<NRxns;i++)
			{
				fo_kf<<kf[i]<<"\t";
				fo_kr<<kr[i]<<"\t";
			}
			fo_kf<<endl;
			fo_kr<<endl;
		}
		if(fin.eof())
			break;
	}
	return;
}


double *deltaG(double x[])
//Calculate deltaG from metabolite concentrations
{
   	updateDepSpeciesValues(x);
	double *dg=new double[NRxns];
	dg[0]=dgv(bc[0],x[12]/p[25]);
	dg[1]=dgv(x[12]*x[1],x[7]*x[0]*bc[3]/p[26]);
	dg[2]=dgv(x[7],x[9]/p[27]);
	dg[3]=dgv(x[9]*x[1],x[16]*x[0]*bc[3]/p[31]);
	dg[4]=dgv(x[16],x[6]*x[2]/p[21]);
	dg[5]=dgv(x[6],x[2]/p[35]);
	dg[6]=dgv(x[2]*xd[3]*x[8],x[15]*x[4]*bc[3]/p[24]);
	dg[7]=dgv(x[15]*x[0],x[10]*x[1]/p[32]);
	dg[8]=dgv(x[10],x[5]/p[33]);
	dg[9]=dgv(x[5],x[14]/p[23]);
	dg[10]=dgv(x[14]*x[0],x[3]*x[1]/p[34]);
	dg[11]=dgv(x[3]*x[4],x[11]*xd[3]/p[29]);
	dg[12]=dgv(x[11],bc[1]/p[28]);
	dg[13]=-1000;
	dg[14]=-1000;
	dg[15]=dgv(x[1],x[0]*x[8]*bc[3]/p[22]);
	dg[16]=dgv(x[1]*xd[0],x[0]*x[0]/p[20]);
	dg[17]=dgv(bc[2],x[13]/p[30]);
	return dg;
}

double *calEC(double *params,double *x)
//Calculate elasticity coefficients
{
	double *drdx=new double[NRxns*NInd];
	gsl_matrix_view drdx_mat=gsl_matrix_view_array(drdx,NRxns,NInd);
	gsl_matrix *DrDx=&drdx_mat.matrix;

	static gsl_matrix *DrDxd=gsl_matrix_alloc(NRxns,NDep);
	static gsl_matrix *DxdDx=gsl_matrix_alloc(NDep,NInd);
   	updateDepSpeciesValues(x);
	getRates(0,x);
#include"dxddx.cpp"
#include"drdx.cpp"
#include"drdxd.cpp"
	gsl_blas_dgemm(CblasNoTrans,CblasNoTrans,1,DrDxd,DxdDx,1,DrDx);
	for(int i=0;i<NRxns;i++)
	{
		for(int j=0;j<NInd;j++)
		{
			double v0=gsl_matrix_get(DrDx,i,j);
			gsl_matrix_set(DrDx,i,j,v0*x[j]/rates[i]);
		}
	}
	return drdx;
}

int main(int argc, char *argv[])
//In order to run this program, do ./gg FluxIdx nsamples
{
	init();
	initParameters();
	const int NVmax=16;
	int FluxIdx=atoi(argv[1]);
	double *params=new double[NParams];
	for(int i=0;i<NParams;i++)
		params[i]=p[i];
	
	//Do the simulation with original parameters
	double *ss=new double[NInd];
	double *ps=calStatus(params,ss);
	double *ec=calEC(params,ss);
	ofstream fe1("EC_Original.txt");
	for(int i=0;i<NRxns*NInd;i++)
		fe1<<ec[i]<<"\t";
	fe1<<endl;
	fe1.close();
	ofstream fs1("MetConc_Original.txt");
	for(int i=0;i<NInd;i++)
		fs1<<ss[i]<<"\t";
	fs1<<endl;
	fs1.close();
	ofstream fout1("Status_Original.txt");
	cout<<"System Status:";
	for(int i=0;i<4;i++)
		cout<<ps[i]<<"\t";
	cout<<endl;
	for(int i=0;i<4;i++)
		fout1<<ps[i]<<"\t";
	fout1<<endl;
	fout1.close();
	double *dg=deltaG(ss);
	ofstream fdg1("deltaG_Original.txt");
	for(int i=0;i<NRxns;i++)
		fdg1<<dg[i]<<"\t";
	fdg1<<endl;
	fdg1.close();
	delete dg;
	delete ps;
	gsl_matrix *m=calFCC(params);
	ofstream fout2("FCC_Original.txt");
	for(int j=0;j<NVmax;j++)
	{
		double FCC_Lac_j=gsl_matrix_get(m,FluxIdx,j);
		cout<<FCC_Lac_j<<"\t";
		fout2<<FCC_Lac_j<<"\t";
	}
	fout2<<endl;
	fout2.close();
	cout<<endl;


	//Do the simulation with sampled parameters
	int nsamples=atoi(argv[2]);
	double **PCM=Samp_ParamsChange(nsamples);
	cout<<"Parameter sampling finished"<<endl;
	ofstream fout3("Status_Sample.txt");
	ofstream fout4("FCC_Sample.txt");
	ofstream fs2("MetConc_Sample.txt");
	ofstream fdg2("deltaG_Sample.txt");
	ofstream fe2("EC_Sample.txt");
	ofstream fp("Params_Sample.txt");
	ofstream fr("Fluxes_Sample.txt");
	for(int i=0;i<nsamples;i++)
	{
		double *PCV=PCM[i];
		double *randp=ChangeParams(PCV,params);
		ps=calStatus(randp,ss);
		cout<<"System Status:";
		for(int j=0;j<4;j++)
			cout<<ps[j]<<"\t";
		cout<<endl;
		if(ps[0]>0)
		{
			for(int j=0;j<NRxns;j++)
				fr<<rates[j]<<"\t";
			fr<<endl;
			for(int j=0;j<4;j++)
				fout3<<ps[j]<<"\t";
			fout3<<endl;
			for(int j=0;j<NInd;j++)
				fs2<<ss[j]<<"\t";
			fs2<<endl;
			gsl_matrix *m=calFCC(randp);
			for(int j=0;j<NVmax;j++)
			{
				double FCC_Lac_j=gsl_matrix_get(m,FluxIdx,j);
				cout<<FCC_Lac_j<<"\t";
				fout4<<FCC_Lac_j<<"\t";
			}
			dg=deltaG(ss);
			for(int j=0;j<NRxns;j++)
				fdg2<<dg[j]<<"\t";
			fdg2<<endl;
			cout<<endl;
			fout4<<endl;
			for(int j=0;j<NParams;j++)
				fp<<randp[j]<<"\t";
			fp<<endl;
			ec=calEC(randp,ss);
			for(int j=0;j<NRxns*NInd;j++)
				fe2<<ec[j]<<"\t";
			fe2<<endl;

			delete dg;
		}
	}
	fs2.close();
	fout3.close();
	fout4.close();
	fdg2.close();
	fp.close();
	fe2.close();
	fr.close();
	Conc2Sat();
	
	return 0;
}
